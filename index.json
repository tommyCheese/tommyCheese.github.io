[{"content":"\u003ch1 id=\"领域驱动设计概述\"\u003e领域驱动设计概述\u003c/h1\u003e\n\u003cp\u003e领域驱动设计（DDD, Domain-Driven Design）是一种模型驱动设计的方法，它通过领域模型捕捉领域知识，使用领域模型构造\u003cstrong\u003e更易维护\u003c/strong\u003e的软件.\u003c/p\u003e\n\u003cp\u003eDDD的设计过程分为战略设计与战术设计，其中战略设计面向领域、子域以及限界上下文的设计，而战术设计面向实体、值对象、领域事件等设计，关系如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/DDD1.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003ch2 id=\"战略设计阶段相关概念\"\u003e战略设计阶段相关概念\u003c/h2\u003e\n\u003ch3 id=\"领域\"\u003e领域\u003c/h3\u003e\n\u003cp\u003e领域是系统要解决问题的领域，如商品信息管理就可以是系统要解决问题的领域.\u003c/p\u003e\n\u003ch3 id=\"子域\"\u003e子域\u003c/h3\u003e\n\u003cp\u003e根据使用语言的不同可以将领域划分为不同的子域：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e核心域：决定产品核心竞争力的子域，是最为重要、业务最核心、个性的部分；\u003c/li\u003e\n\u003cli\u003e通用域：被多个子域使用的通用功能子域，比如用到的通用系统，例如认证、权限等等，这类应用没有企业特点限制，不需要做太多的定制化；\u003c/li\u003e\n\u003cli\u003e支撑域：不包含核心功能与通用功能的子域，具有企业特性，但不具有通用性，例如数据代码类的数据字典等系统；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"限界上下文\"\u003e限界上下文\u003c/h3\u003e\n\u003cp\u003e限界上下文，即限定使用不同模型来解决不同问题所产生的不同区域.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e限界上下文是一个子域或者多个子域的集合\u003c/strong\u003e，\u003cstrong\u003e要保证一个限界上下文须支持一个完整的业务流程\u003c/strong\u003e，\u003cstrong\u003e保证这个业务流程所涉及的领域都在一个限界上下文中\u003c/strong\u003e.限界上下文是微服务拆分的依据，即每个限界上下文对应一个微服务.\u003c/p\u003e\n\u003cp\u003e那么为什么要进行限界上下文呢？这是因为\u003cstrong\u003e上下文\u003c/strong\u003e的存在导致编码十分困难，举个例子说明：\u003c/p\u003e\n\u003cp\u003e例如在招聘域我们可能会使用“平台”来表明来自于哪个学校、机构；在跳水域我们使用“平台”来表明选手从那个跳台跳水；而在铁路交通运输领域，我们可能会使用“平台”来描述铁路站台……在某一天的某一个机会，跳水选手、HR和乘务员聚到了一起，并且他们都不了解对方的身份，如果此时HR问跳水选手说你来自哪个平台……\u003c/p\u003e\n\u003cp\u003e看到了吧，同样是使用“平台”这个词语，但三个人在\u003cstrong\u003e没有约定\u003c/strong\u003e的情况下可能对于词语的理解不尽相同，解决这个问题的办法就是把跳水域、招聘域和交通域隔离，分别定义域内的术语，在一个域内讨论就可以最大可能的避免歧义，这就是约定.这也是为什么最好把业务所涉及的领域定义在一个限界上下文中：减少歧义.\u003c/p\u003e\n\u003cp\u003e在软件系统的设计中同样会遇到类似的问题，如果你负责设计一个足够大的计算机软件产品，产品涉及到跳水服务、招聘服务与乘车服务，系统没有对服务做任何切分，你在跳水有关业务逻辑中使用platform数据结构描述跳台、在招聘业务中使用platform代表平台、在交通业务中使用platform代表站台，当这三个业务不可避免的交汇到一起时，灾难就发生了，面对满屏幕不同语义但几乎同名的变量，我们能怎么办？\u003c/p\u003e\n\u003cp\u003e显然，限定某一个领域术语的细节，我们就可以在领域中畅通无阻的使用这个术语了，这就是限界上下文的重要作用.\u003c/p\u003e\n\u003ch2 id=\"战术设计阶段相关概念\"\u003e战术设计阶段相关概念\u003c/h2\u003e\n\u003ch3 id=\"值对象和实体\"\u003e值对象和实体\u003c/h3\u003e\n\u003cp\u003e首先了解一下值对象和实体.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e值对象是通过属性值来识别的对象，即如果两个值对象的内部值都是相同的，那么我们就认为这两个值对象是相同的.显然，值对象的属性不可变.\u003c/li\u003e\n\u003cli\u003e实体是拥有唯一标识和状态，且具有生命周期的业务对象.实体的属性是可变的，如果两个实体的属性是完全相同的，我们也不认为他们是相同的实体，只有他们两个的标识（如ID）是相同的才会被认为是相同的实体.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e举例区分值对象和实体：\u003c/p\u003e\n\u003cp\u003e假如现在我们有一个白色值对象Color white{R:255, G:255, B:255}和一个轮胎实体tire{Air:\u003cem\u003e,Size:\u003c/em\u003e}：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可变性：白色中的每一个属性都是不可变的，因为一旦变化此对象就不再代表”白色“；而轮胎中的气压、尺寸等值可以改变，因为了即便这些参数发生了变化它仍然是轮胎；\u003c/li\u003e\n\u003cli\u003e可比较性：正是由于值对象的值不可变性赋予了其相等的规则，两个白色对象的值一定会是相同的，因此如果两个值对象的内部值都是相同的，那么我们就认为这两个值对象是相同的，实体则由于其属性的可变性而丧失了这个特点.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于实体而言，其形态一般有四种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e失血模型：模型仅仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放到服务层中.这种类在Java中叫POJO.\u003c/li\u003e\n\u003cli\u003e贫血模型：贫血模型中包含了一些业务逻辑，但不包含依赖持久层的业务逻辑.这部分依赖于持久层的业务逻辑将会放到服务层中.\u003c/li\u003e\n\u003cli\u003e充血模型：充血模型中包含了所有的业务逻辑，包括依赖于持久层的业务逻辑.\u003c/li\u003e\n\u003cli\u003e胀血模型：胀血模型就是把和业务逻辑不相关的其他应用逻辑（如授权、事务等）全部都放到领域模型中.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e资源库Repo\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRepo是针对Entity设计的存储操作，Repo中的操作应该尽可能低级、命名要简短，并且不能定义太多.Java中的MyBatis Mapper可以看作是Repo的一种实现.\u003c/p\u003e\n\u003ch3 id=\"聚合与聚合根\"\u003e聚合与聚合根\u003c/h3\u003e\n\u003cp\u003e聚合是一种更大范围的封装，把一组有相同生命周期、在业务上不可分隔的实体和值对象放在一起考虑，只有聚合根可以对外暴露引用，聚合也是一种内聚性的表现.聚合根之间也可相互调用，聚合根抽象出来一般名字为名词.\u003c/p\u003e\n\u003cp\u003e聚合根通过以下几种手段实现封装：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e必须通过操作聚合根来实现操作整个聚合，外部操作不允许直接操作聚合中的元素.比如紫色（外观）+轮胎+钢架+\u0026hellip;=汽车，我们开车时不能也不会去单独操作轮胎、方向盘、外观\u0026hellip;，相反，我们通过操作汽车这个聚合根来间接操作其他实体/值对象.\u003c/li\u003e\n\u003cli\u003e聚合定义了一组\u003cstrong\u003e边界\u003c/strong\u003e，边界内所有的组件必须对业务逻辑有效；\u003c/li\u003e\n\u003cli\u003e必须在一个原子性的事务中操作聚合，否则可能会出现异常，也就是说聚合是操作的单元，从仓库取出聚合、操作完成后放回是一个原子性的操作；如何理解原子性？加入汽车聚合根有轮子实体、钢/铝/碳架实体，你不能拆掉汽车的一个轮子检修完后不装上.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"领域事件domain-events\"\u003e领域事件Domain Events\u003c/h3\u003e\n\u003cp\u003e当实体的属性发生变化时就会产生领域事件，领域事件是领域专家认为重要的事情.领域事件是发生在领域中且值得注意的事件.而领域事件通常意味着领域对象状态的改变.\u003cstrong\u003e领域事件在系统中起到了传递消息、触发其他动作的作用，是解耦领域模型的重要手段之一\u003c/strong\u003e.我们往往利用\u003cstrong\u003e消息队列\u003c/strong\u003e来传递领域事件，这样所有订阅此消息的子域都会进行自己内部的响应操作.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e消息总线也是一种实现方法👋.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如轮胎实体气压发生变化时，会释放领域leaked漏气事件，此漏气事件传递了“轮胎漏气”这个消息，从而引发一系列其他的响应，如动能系统变化、方向盘手感变化等等，领域事件通常会使用过去式命名来说明事件已经发生，不可撤销.\u003c/p\u003e\n\u003ch3 id=\"领域服务domain-service\"\u003e领域服务Domain Service\u003c/h3\u003e\n\u003cp\u003e有些领域中的动作看上去\u003cstrong\u003e并不属于任何对象\u003c/strong\u003e.它们代表了领域中的一个重要的行为，不能忽略它们或者简单地把它们合并到某个实体或者值对象中.当这样的行为从领域中被识别出来时，推荐的实践方式是将它声明成一个服务，这个服务就是领域服务.\u003c/p\u003e\n\u003cp\u003e领域服务不是微服务中的“服务”概念.服务和聚合根概念有些相近，他们都可以操作多个实体，但是二者理念和作用不同，\u003cstrong\u003e聚合根是对实体的组合，而服务是用于同步多个实体的状态，比如将某个item实体加入到list实体\u003c/strong\u003e（比如把mail投递到inbox）.所以Servie一般抽象出来都是动词.\u003c/p\u003e\n\u003ch2 id=\"ddd领域建模设计领域模型\"\u003eDDD领域建模（设计领域模型）\u003c/h2\u003e\n\u003cp\u003eDDD领域建模一般步骤如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e根据需求划分出初步的子域和限界上下文，以及上下文之间的关系；\u003c/li\u003e\n\u003cli\u003e进一步分析每个上下文内部，识别出哪些是实体，哪些是值对象，并确定实体需要使用哪种代码形态：失血、贫血、充血、胀血；\u003c/li\u003e\n\u003cli\u003e对实体、值对象进行关联和聚合，划分出聚合的范畴和聚合根；\u003c/li\u003e\n\u003cli\u003e为聚合根设计资源库repo，并思考实体或值对象的创建方式；\u003c/li\u003e\n\u003cli\u003e在工程中实践领域模型，并在实践中检验模型的合理性，倒推模型中不足的地方并重构.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这就是DDD采用两阶段设计原则——先进行战略设计、随后进行战术设计。\u003c/p\u003e\n\u003cp\u003e在实践中，建议实体采用失血模型（实体方法只包括setter/getter）或者贫血模型（包含不涉及数据库操作的简单逻辑，如属性合法性校验）；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e实际上这是DDD建模方式之一，是自顶向下的设计方法，还存在一种方式是使用自下而上的方法，即先确定领域模型——实体、值对象等，再确定子域、限界上下文\u0026hellip;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e（本节完）\u003c/p\u003e\n","description":"本文描述领域驱动设计方法的基本概念和实践","image":"/blogimages/DDD1.png","permalink":"https://tommycheese.github.io/blogs/ddd%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%88%9D%E8%AF%86/","title":"领域驱动设计初识"},{"content":"\u003ch1 id=\"再读整洁架构之道四组件构建原则\"\u003e再读整洁架构之道（四）组件构建原则\u003c/h1\u003e\n\u003cp\u003e第三篇主要叙述如何设计模块和类，在本篇将会更近一步，叙述如何进行组件的设计。\u003c/p\u003e\n\u003cp\u003e组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体，组件可以被单独开发，组件化的插件式架构已经成为我们习以为常的软件构建形式了。\u003c/p\u003e\n\u003ch2 id=\"组件聚合\"\u003e组件聚合\u003c/h2\u003e\n\u003cp\u003e组件聚合告诉我们哪些模块和类应该组合在一起形成组件。主要有三个原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e复用/发布等同原则；\u003c/li\u003e\n\u003cli\u003e共同闭包原则；\u003c/li\u003e\n\u003cli\u003e共同复用原则；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"复用发布等同原则rep\"\u003e复用/发布等同原则REP\u003c/h3\u003e\n\u003cp\u003eREP指出软件复用的最小粒度应等同于其发布的最小粒度。\u003c/p\u003e\n\u003cp\u003eREP是从代码复用角度考虑的，它规定了具备相同主题和功能的代码可以进行组合形成组件。REP建议软件复用应该按照组件来进行的。\u003c/p\u003e\n\u003cp\u003e通俗来讲，某个组件打包发布后可能会形成版本号或唯一标识，我们通过引入现成代码库的方式复用代码，引入的单位就是组件打包的结果，引入的凭据就是版本号。\u003c/p\u003e\n\u003ch3 id=\"共同闭包ccp\"\u003e共同闭包CCP\u003c/h3\u003e\n\u003cp\u003eCCP指出我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。\u003c/p\u003e\n\u003cp\u003eCCP是从代码维护角度考虑的，对于由于同一原因/修改目的代码应该组合形成组件，这样就可以有效地降低因软件发布、验证及部署所带来的工作压力。\u003c/p\u003e\n\u003cp\u003e前面说过，CCP是SRP的组件版，SRP和CCP都可以用以下的语言概括：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e将由于相同原因而修改，并且需要同时修改的“东西”放在一起。将由于不同原因而修改，并且不同时修改的东西分开。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在SRP中，东西是指函数和其他组成类或模块的成分；\u003c/li\u003e\n\u003cli\u003e在CCP中，东西是指构成组件的类和模块。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"共同复用crp\"\u003e共同复用CRP\u003c/h3\u003e\n\u003cp\u003eCRP指出不要强迫一个组件的用户依赖他们不需要的东西。\u003c/p\u003e\n\u003cp\u003eCRP规定了对于使用场景不同、使用频次不同的代码需要进行拆分到不同的组件中。CRP 是为了避免不必要的切分，是ISP接口隔离原则的普适版。\u003c/p\u003e\n\u003cp\u003eCRP是接口隔离的普适版，ISP和CRP都可以用以下的语言概括：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e不要依赖不需要用到的“东西”。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在ISP中，东西是指包含不需要的方法的函数/类；\u003c/li\u003e\n\u003cli\u003e在CCP中，东西是指包含不需要的函数的类/模块；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"思考\"\u003e思考\u003c/h3\u003e\n\u003cp\u003e那么REP、CCP、CRP三者之间有什么关系呢？\u003c/p\u003e\n\u003cp\u003e实际上三者存在着\u003cstrong\u003e竞争关系\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eREP和CCP是黏合性原则，它们指导我们应该把哪些类/模块放在一起形成组件，而CRP属于排他性原则，它知道我们哪些类/模块不应该放在一起。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blogimages/image-20240706143525187.png\" alt=\"image-20240706143525187\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果架构师只关注REP和CCP，那么会发现软件依赖了的组件中包含了很多并不需要的部分，这样会导致太多不必要的发布；\u003c/li\u003e\n\u003cli\u003e如果架构师只关注CRP和CCP，那么会发现软件的复用会变得非常困难；\u003c/li\u003e\n\u003cli\u003e如果架构师只关注REP和CRP，那么会发现如果部分类/模块需要变更，很多相关模块也不可避免的要跟随变更；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e软件架构师的任务就是要在这三个原则中间进行取舍，组件的构成安排应随着项目重心的不同，以及研发性与复用性的不同而不断演化，因此确定项目朝着哪个方向演进是要动态判断的。\u003c/p\u003e\n\u003ch2 id=\"组件耦合\"\u003e组件耦合\u003c/h2\u003e\n\u003cp\u003e组件耦合告诉我们如何安排组件之间的关系。它包含三个原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无依赖环原则ADP；\u003c/li\u003e\n\u003cli\u003e稳定依赖原则SDP；\u003c/li\u003e\n\u003cli\u003e稳定抽象原则SAP；\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"无依赖环原则adp\"\u003e无依赖环原则ADP\u003c/h3\u003e\n\u003cp\u003eADP告诉我们组件依赖关系图中不应该出现环。\u003c/p\u003e\n\u003cp\u003e版本号控制机制解决了一觉醒来综合征的问题，而此机制需要遵循ADP，首先让我们读一下作者是怎么介绍一觉醒来综合征的：\u003c/p\u003e\n\u003cp\u003e当你花了一整天的时间，好不容易搞定了一段代码，第二天上班时却发现这段代码莫名其妙地又不能工作了。这大概率是其他工作人员修改了你项目所依赖的组件。\u003c/p\u003e\n\u003cp\u003e要想解决这个问题一般有两种方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每周构建\u003c/li\u003e\n\u003cli\u003e版本号控制机制\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cu\u003e每周构建\u003c/u\u003e\u003c/strong\u003e：每个人先在自己的代码仓工作，每周固定时间（比如周五）再进行项目构建并处理可能的冲突问题。\u003c/p\u003e\n\u003cp\u003e这种方式的局限性很明显：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e随着项目越来越大，集成工作会越来越难以按时完成\u003c/li\u003e\n\u003cli\u003e整个项目会变得越来越难以构建与测试，团队反馈周期会越来越长，研发质量自然也会越来越差\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此版本号控制机制需要被引入。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cu\u003e版本号控制机制\u003c/u\u003e\u003c/strong\u003e：每当一个组件发布新版本时，其他依赖这个组件的团队都可以自主决定是否立即采用新版本。\u003c/p\u003e\n\u003cp\u003e版本号控制机制\u003cstrong\u003e不允许组件结构依赖关系图中出现环\u003c/strong\u003e，也就是要遵守无依赖换原则ADP，否则一觉醒来综合征是不可避免的。为什么呢？\u003c/p\u003e\n\u003cp\u003e这是因为如果存在依赖环路，环路里的所有组件被组合成了一个更大的组件，这就要求他们都必须使用相同的版本，这样其他的组件才能成功的完成依赖。同样，存在依赖换的系统在测试时也会成为一个棘手的问题，虽然打桩mock技术已经被广泛应用，但同时为环路中的组件重复打桩也已经十分的不优雅了。\u003c/p\u003e\n\u003cp\u003e那么如何消除循环依赖呢？方案有两个：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用依赖反转创建接口；\u003c/li\u003e\n\u003cli\u003e创建新组件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e应用DIP解决循环依赖很好理解，下面讲述一个在工作中遇到的案例来说明如何使用创建新组件来打破循环依赖。\u003c/p\u003e\n\u003cp\u003e现在有这样的一个场景，团队正在使用领域驱动设计的方法设计系统架构，现在实体Entity Dog需要依赖Dog Repo完成Save存储操作。此时Entity模块依赖了Repo模块，很不幸的是在Entity模块中我们还定义了Dog PO（简直糟透了），Repo的Save又需要使用PO来完成对象的转换并存储。此时Entity和Repo之间就发生了循环依赖，幸运的是，在Go中模块之间的相互依赖是不允许的，检查起会提醒“循环导入”错误，怎么处理这个问题呢？\u003c/p\u003e\n\u003cp\u003e答案是我们需要新创建一个PO模块，并把Entity中的PO移动到模块，Repo中依赖PO的函数也要划分到PO中，这样就消除了依赖环。使用依赖注入方法也是一个选择，如果你使用SprintBoot，@AutoWired即可解决此问题，但其本质也是创建了一个新组件——依赖池，消除了依赖环。\u003c/p\u003e\n\u003cp\u003e类似的例子还有很多很多，是否还记得我们使用anaconda下载Python库时遇到的库版本冲突问题……\u003c/p\u003e\n\u003cp\u003e在这里多插一句，笔者在设计组件结构的时候很自然的就想到要和系统功能对应，也就是说，组件应该是和系统功能一一对应的，这样组件依赖图就和系统功能模块划分也一一对应起来。想当然认为在系统设计的一开始组件依赖结构图也就产出了。\u003c/p\u003e\n\u003cp\u003e但作者特别提到，自顶向下的设计是不可能的。让我们看看书中是怎么描述的：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\u003c/p\u003e\n\u003cp\u003e组件结构图必须随着软件系统的变化而变化和扩张，而不可能在系统构建的最初就被完美设计出。因为组件依赖结构图并不和功能一一对应，它更像是应用程序在构建性与维护性方面的一张地图。\u003c/p\u003e\n\u003cp\u003e被设计并实现出来的模块越来越多，项目中就逐渐出现了要对组件依赖关系进行管理的需求，我们希望将项目变更所影响的范围被限制得越小越好，因此需要应用单一职责原则(SRP)和共同闭包原则(CCP)来将经常同时被变更的类聚合在一起。\u003c/p\u003e\n\u003cp\u003e组件结构图中的一个重要目标是指导如何隔离频繁的变更。我们不希望那些频繁变更的组件影响到其他本来应该很稳定的组件。\u003c/p\u003e\n\u003cp\u003e另外，随着应用程序的增长，创建可重用组件的需要也会逐渐重要起来。这时CRP又会开始影响组件的组成。最后当循环依赖出现时，随着无循环依赖原则(ADP)的应用，组件依赖关系会产生相应的抖动和扩张。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"稳定依赖原则sdp\"\u003e稳定依赖原则SDP\u003c/h3\u003e\n\u003cp\u003eSDP告诉我们依赖关系必须要指向更稳定的方向。通常来说，要做到软件架构的越底层越稳定。\u003c/p\u003e\n\u003cp\u003e任何一个我们预期会经常变更的组件都不应该被一个难于修改的组件所依赖，否则这个多变的组件也将会变得非常难以被修改。这就是软件开发的困难之处，我们精心设计的一个容易被修改的组件很可能会由于别人的一条简单依赖而变得非常难以被修改，通过遵循SDP，这样的问题就能够被避免。\u003c/p\u003e\n\u003cp\u003e判断组件是否稳定，可以使用稳定性指标。作者定义稳定性指标可以通过如下公式计算：\n$$\nI=\\frac{Fan-out}{Fan-in+Fan-out}\n$$\n其中Fan-in为组件的入依赖数量，Fan-out为出依赖数量，这意味着一个组件的出依赖越少越稳定，因为如果出依赖为 0 意味着没有因素可以让组件改变。\u003c/p\u003e\n\u003cp\u003e稳定依赖原则(SDP)的要求就是要让每个组件的I指标都必须大于其所依赖组件的I指标（即被指向的组件更稳定）。\u003c/p\u003e\n\u003cp\u003eSDP并不是要求所有组件都应该是稳定的，我们设计组件架构图的目的就是要决定应该让哪些组件稳定，让哪些组件不稳定，所有组件都稳定的架构是不灵活的，不灵活的架构没有足够的架构价值。\u003c/p\u003e\n\u003ch3 id=\"稳定抽象原则sap\"\u003e稳定抽象原则SAP\u003c/h3\u003e\n\u003cp\u003eSAP指出一个组件的抽象化程度应该与其稳定性保持一致。\u003c/p\u003e\n\u003cp\u003e高层策略等应该存在稳定的组件中，但这样做会导致高层策略很难修改，幸运的是开闭原则 OCP 告诉我们稳定的组件可以被设计成容易扩展的，抽象类具有稳定抽象能力，可以设计一个抽象类具有较好的稳定性并且易于扩展和修改。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e抽象类是接口和类之间的缓冲地带。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e稳定抽象原则(SAP)为组件的稳定性与它的抽象化程度建立了一种关联。原则要求稳定的组件同时应该是抽象的，这样它的稳定性就不会影响到扩展性。同时一个不稳定的组件应该包含具体的实现代码，这样它的不稳定性就可以通过具体的代码被轻易修改。因此，如果一个组件想要成为稳定组件，那么它就应该由接口和抽象类组成，以便将来做扩展。\u003c/p\u003e\n\u003cp\u003e和稳定性类似，我们也可以使用抽象程度指标来衡量组件的抽象程度：\n$$\nA=\\frac{N_c}{N_a}\n$$\n其中Nc是指组件中类的数量，而Na是组件中抽象类和接口的数量。A指标的取值范围是从0到1，值为0代表组件中没有任何抽象类，值为1就意味着组件中只有抽象类。\u003c/p\u003e\n\u003ch3 id=\"思考-1\"\u003e思考🤔\u003c/h3\u003e\n\u003cp\u003eSDP和SAP有什么关联吗？\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e第一点，从SDP、SAP与DIP上说\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e实际上，SDP+SAP=组件DIP。因为SDP要求的是让依赖关系指向更稳定的方向，而SAP则告诉我们稳定性本身就隐含了对抽象化的要求，即依赖关系应该指向更抽象的方向。\u003c/p\u003e\n\u003cp\u003e怎么理解这句话呢？\u003c/p\u003e\n\u003cp\u003e可以想到，DIP在类上的作用是为了保证灵活性，SDP+SAP实际上就是为了保证组件在稳定的基础上足够灵活，并且 DIP 和 SDP+SAP 在软件架构上的影响都是具体实现类指向抽象类/接口，因此从作用上看SDP+SAP=组件DIP。\u003c/p\u003e\n\u003cp\u003e但是DIP和SDP+SAP还是有不同之处，对类来说，设计是没有灰色地带的，一个类要么是抽象类，要么就不是。SDP与SAP这对原则是应用在组件层面上的，我们要允许一个组件部分抽象，部分稳定。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e其次，从SAP和SDP的目的达成来说\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e此外，SDP指出依赖应该指向稳定的位置，SAP要求我们在设计组件时，高层的策略应该设计在抽象的组件，以便我们在架构设计时将策略与细节分开，同时便于我们进行插件式开发，SDP和SAP他们在目的上是一致的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e看到了吧，这里又提到了\u003cstrong\u003e插件式开发\u003c/strong\u003e这个词，上次是在哪里提到的？对，依赖反转DIP，这也说明了SAP+SDP确实类似于组件DIP。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"主序列\"\u003e主序列\u003c/h3\u003e\n\u003cp\u003e把组件稳定性指标I与组件抽象程度指标A结合在一起，画出一张图，a=-i+1这条直线就叫做主序列线。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blogimages/image-20240706171725797.png\" alt=\"image-20240706171725797\"\u003e\u003c/p\u003e\n\u003cp\u003e整个区域可以分为三个区域：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e痛苦区：靠近(0,0)的区域，在这个区域内的组件十分稳定但同时又十分的具体，因此不易改变，如数据库表；工具库也是处于痛苦区的组件，虽然其 I 指标为 1（工具库依赖非常多的组件，因此其不稳定），但不能被修改，否则很多代码会出现问题；\u003c/li\u003e\n\u003cli\u003e无用区：处于(1,1)附近的组件，该位置上的组件通常是无限抽象的，但是没有被其他组件依赖，这样的组件往往无法使用，对于这个区域中的软件组件来说，其源码或者类中的设计问题通常是由于历史原因造成的，比如忘记清除的旧代码；\u003c/li\u003e\n\u003cli\u003e主序列线区：在整条主序列线上的区域，组件所能处于最优的位置是线的两端(0, 1)与(1, 0)。一个优秀的软件架构师应该争取将自己设计的大部分组件尽可能地推向这两个位置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e怎么衡量组件的综合性能呢？答案是计算它与主序列线的距离，来量化一个系统设计与主序列的契合程度，这个值为D值，值为0意味着组件是直接位于主序列线上的，值为1则意味着组件在距离主序列最远的位置。\n$$\nD=|A+I-1|\n$$\n这样我们就可以用D指标大于0多少来指导组件的重构与重新设计。\u003c/p\u003e\n\u003cp\u003e除此以外，D还可以有更多的作用，比如计算设计中所有组件的D指标的平均值和方差，用统计学的方法来量化分析一个系统设计：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于一个良好的系统设计来说，D指标的平均值和方差都应该接近于0；\u003c/li\u003e\n\u003cli\u003e方差作为组件的“达标红线”来使用，我们可以通过它找出系统设计中那些不合常规的组件；\u003c/li\u003e\n\u003cli\u003e还可以按照时间追踪 D 的方差值，来观察随着时间的变化，软件系统架构的稳定和抽象变化。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（第四篇完）\u003c/p\u003e\n","description":"再读整洁架构之道（四）组件构建原则","image":"/blogimages/arh4.png","permalink":"https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E5%9B%9B/","title":"再读整洁架构之道（四）组件构建原则"},{"content":"\u003ch1 id=\"再读整洁架构之道三solid原则\"\u003e再读整洁架构之道（三）SOLID原则\u003c/h1\u003e\n\u003cp\u003e构建软件模块的主要目标有三个：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使软件可容忍被改动\u003c/li\u003e\n\u003cli\u003e使软件更容易被理解\u003c/li\u003e\n\u003cli\u003e构建可在多个软件系统中复用的组件\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSOLID原则的主要作用就是告诉我们如何将数据和函数组织成为类，以及如何将这些类链接起来成为程序。SOLID原则指导我们如何设计模块，在架构设计层面，我们会有其他的设计原则。\u003c/p\u003e\n\u003cp\u003eSOLID原则是指单一职责原则\u003cstrong\u003eS\u003c/strong\u003eRP、开闭原则\u003cstrong\u003eO\u003c/strong\u003eCP、里式替换原则\u003cstrong\u003eL\u003c/strong\u003eSP、接口隔离原则\u003cstrong\u003eI\u003c/strong\u003eSP和接口反转\u003cstrong\u003eD\u003c/strong\u003eIP。\u003c/p\u003e\n\u003ch2 id=\"单一职责原则srp\"\u003e单一职责原则SRP\u003c/h2\u003e\n\u003cp\u003eSRP定义每个软件模块只对一个功能负责，\u003cstrong\u003e只有一个理由可以让模块改变\u003c/strong\u003e，任何一个软件模块都应该只对某一类行为者负责。\u003c/p\u003e\n\u003cp\u003e组件层面的SRP被称作共同闭包原则CCP。\u003c/p\u003e\n\u003cp\u003e倘若设计模块时没有遵循SRP会发生什么呢？一起看一个例子。\u003c/p\u003e\n\u003cp\u003e如果财务部门、人事部门、研发部门共同依赖于一个工资、工时计算的程序，程序包含三个函数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCalculateSalary：计算工资；\u003c/li\u003e\n\u003cli\u003eCalculateTime：计算工时；\u003c/li\u003e\n\u003cli\u003eSave：保存信息；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e三个部门平静地使用着程序，突然有一天，财务部的薪资计算发生变化，因此财务部门的维护人员更改了CalculateSalary函数；然后，诡异的事情发生了，人事部门、研发部薪资也同时变化了\u0026hellip;\u003c/p\u003e\n\u003ch2 id=\"开闭原则ocp\"\u003e开闭原则OCP\u003c/h2\u003e\n\u003cp\u003e“拥抱新增、抗拒修改！”\u003c/p\u003e\n\u003cp\u003eOCP指出：如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码。设计良好的计算机软件应该易于扩展，同时抗拒修改。\u003c/p\u003e\n\u003cp\u003eOCP不仅适用于类和模块的设计，也适用于组件的设计。他起源于设备无关性的概念。具体来说，我们使用依赖反转将IO设备设计成插件，这样的我们就能很轻易的新增IO设备，而不去修改原有的IO设备。\u003c/p\u003e\n\u003cp\u003eOCP的实现方式是通过将系统划分为一系列组件，并且将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响。\u003c/p\u003e\n\u003ch2 id=\"里式替换lsp原则\"\u003e里式替换LSP原则\u003c/h2\u003e\n\u003cp\u003eLSP指出：如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便让这些组件可以相互替换。\u003c/p\u003e\n\u003cp\u003eLSP的本质是一个可替换性原则：如果对于每个类型是S的对象o1都存在一个类型为T的对象o2，能使操作T类型的程序P在用o1替换o2时行为保持不变，我们就可以将S称为T的子类型。\u003c/p\u003e\n\u003cp\u003eLSP可以且应该被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增添大量复杂的应对机制。\u003c/p\u003e\n\u003ch2 id=\"接口隔离原则isp\"\u003e接口隔离原则ISP\u003c/h2\u003e\n\u003cp\u003eISP指出：应该在设计中避免不必要的依赖，任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦。\u003c/p\u003e\n\u003ch2 id=\"依赖反转dip\"\u003e依赖反转DIP\u003c/h2\u003e\n\u003cp\u003eDIP指出该设计原则指出高层策略性的代码不应该依赖实现底层细节的代码，恰恰相反，那些实现底层细节的代码应该依赖高层策略性的代码。\u003c/p\u003e\n\u003cp\u003e通俗理解依赖反转：这需要使用控制流和源代码依赖流来说明。控制流譬如A组件流向B组件，此时B需要知道A的实现，A也需要引入B的模块，代码依赖上也就不可避免的A组件流向了B组件。此时系统行为决定了控制流，而控制流则决定了源代码依赖关系，软件架构就别无选择。但是通过引入接口，B组件此时只需要实现接口，接口引入B，A引入接口，此时A就无需引入B模块，此时的控制流和源代码依赖是反向的，也就是“依赖反转”。\u003c/p\u003e\n\u003cp\u003e依赖反转给了软件架构设计的自由，如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型（接口、抽象类等），而非具体实现。\u003c/p\u003e\n\u003cp\u003eDIP可以归纳出几条编码守则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类；\u003c/li\u003e\n\u003cli\u003e不要在具体实现类上创建衍生类；\u003c/li\u003e\n\u003cli\u003e不要覆盖(override)包含具体实现的函数；\u003c/li\u003e\n\u003cli\u003e应避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物的名字。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（第三篇完）\u003c/p\u003e\n","description":"再读整洁架构之道（三）SOLID设计原则","image":"/blogimages/arh3.png","permalink":"https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%B8%89/","title":"再读整洁架构之道（三）SOLID设计原则"},{"content":"\u003ch1 id=\"再读整洁架构之道二\"\u003e再读整洁架构之道（二）\u003c/h1\u003e\n\u003cp\u003e编程范式指的是程序的编写模式，它告诉我们应该在什么时候采用什么样的代码结构。\u003c/p\u003e\n\u003cp\u003e截止目前，一共出现了三种编程范式：结构化编程范式、面向对象编程范式和函数式编程。\u003c/p\u003e\n\u003cp\u003e作者认为，每种编程方式不是在给架构设计者的武器库进行扩充，相反，架构师和程序员的武器已经够多了，这三种编程范式是在对他们利用的武器进行\u003cstrong\u003e限制\u003c/strong\u003e，这也是为什么他们叫做“范式”。\u003c/p\u003e\n\u003ch2 id=\"结构化编程范式\"\u003e结构化编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e结构化编程对程序控制权的直接转移进行了限制和规范，特别指的是限制了程序中goto的随意使用。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"分解程序\"\u003e分解程序\u003c/h3\u003e\n\u003cp\u003eDijkstra希望使用数学推导方法对程序进行推理证明：让程序就成为了一种欧几里得结构，这样可以用一些已经证明的结构串联起新的程序，从而进一步推导整个程序的正确性。\u003c/p\u003e\n\u003cp\u003e他还发现，如果程序中包含大量的goto，那么程序会变得难以分解，而goto语句的作用完全可以依靠分支和循环来完成。\u003c/p\u003e\n\u003cp\u003e这样，结构化编程范式表明，程序可以进行降解拆分，一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此无限递归。更重要的是，每个被拆分出来的函数也都可以用结构化编程范式来书写。\u003c/p\u003e\n\u003cp\u003e但是，这种形式化证明的编程方式没有成为主流，科学证明法是目前使用较多的方法。\u003c/p\u003e\n\u003ch3 id=\"科学证明法\"\u003e科学证明法\u003c/h3\u003e\n\u003cp\u003e科学理论和科学定律可以被证伪，但是没有办法被证明，类似的，程序只能测试证伪，不能证明，即“测试只能展示Bug的存在，并不能证明不存在Bug”。因此，利用科学证明法，结构化编程范式就可以促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的\u003cstrong\u003e测试\u003c/strong\u003e来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。\u003c/p\u003e\n\u003ch2 id=\"面向对象编程范式\"\u003e面向对象编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e面向对象编程对程序控制权的间接转移进行了限制和规范。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e具体来说，面向对象编程凡事使用\u003cstrong\u003e多态特性\u003c/strong\u003e限制了函数指针的使用。这可以理解为函数指针只能进行有限制的指向，比如java中的多态一般出现在有继承关系的两个类的对象之间。\u003c/p\u003e\n\u003cp\u003e作者也认为多态是OOP的最大特性，利用多态可以做到\u003cstrong\u003e依赖反转\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e依赖反转即引入接口，完全控制系统中所有源代码的依赖关系，而不需要收到系统控制流的制约。\u003c/p\u003e\n\u003cp\u003e依赖反转保证了我们可以对系统进行插件式的开发，如将web UI和数据库与业务逻辑之间的依赖进行反转，可以保证主业务逻辑与UI和数据库的解耦，这样UI和数据库就成了主业务逻辑的插件。\u003c/p\u003e\n\u003cp\u003e面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。\u003c/p\u003e\n\u003ch2 id=\"函数式编程范式\"\u003e函数式编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e函数式编程对程序中的赋值进行了限制和规范。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e换句话说，函数式编程语言中变量是不可变的。\u003c/p\u003e\n\u003cp\u003e作者有以下的观点，这一段话来自原文：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题\u0026quot;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果不考虑储存器与处理器的速度限制，那么不可变性是可行的，但实际上我们必须考虑这些因素，因此可变性只能在一定程度上可行，需要让不可变性在一定程度上可行需要完成\u003cstrong\u003e可变性的隔离\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"可变性的隔离\"\u003e可变性的隔离\u003c/h3\u003e\n\u003cp\u003e可变性隔离的一种常见方式是将应用程序，或者是应用程序的内部服务进行切分，\u003cstrong\u003e划分为可变的和不可变的两种组件\u003c/strong\u003e。不可变组件用纯函数的方式来执行任务，期间不更改任何状态。这些不可变的组件将通过与一个或多个非函数式组件（即可变组件）通信的方式来修改变量状态。\u003c/p\u003e\n\u003cp\u003e一个例子是GIT版本管理工具。它通过移动指针来记录文件的变化：增删改，但实际上文件并没有被真正的修改和删除，只存在增加和检索查询两种情况，这不就是不可变性的一个例子吗。\u003c/p\u003e\n\u003cp\u003e同时，mysql中的事务管理、事务性内存的工作也都运用了这个思想。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e三种编程范式与软件架构具有密切的关系：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多态是我们跨越边界的手段；\u003c/li\u003e\n\u003cli\u003e函数式编程是我们规范和限制数据存放位置与访问权限的手段；\u003c/li\u003e\n\u003cli\u003e结构化编程则是个模块的实现基础；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e三种编程范式与软件架构的三大关注重点不谋而合：\u003cstrong\u003e组件独立性\u003c/strong\u003e（面向对象）、\u003cstrong\u003e数据管理\u003c/strong\u003e（函数式）以及功能性（结构）。\u003c/p\u003e\n\u003ch2 id=\"再次思考\"\u003e再次思考\u003c/h2\u003e\n\u003cp\u003e三种编程范式都对程序员提出了新的\u003cstrong\u003e限制\u003c/strong\u003e。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，编程范式带来的是——什么不应该做。\u003c/p\u003e\n\u003cp\u003e（第二篇完）\u003c/p\u003e\n","description":"再读整洁架构之道（二）编程范式","image":"/blogimages/arh2.png","permalink":"https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%BA%8C/","title":"再读整洁架构之道（二）编程范式"},{"content":"\u003ch2 id=\"前记\"\u003e前记\u003c/h2\u003e\n\u003cp\u003e为什么是再读？因为在这之前笔者已经阅读过一遍架构之道这本书，但当时缺乏项目的锻炼和试错，总觉得读的不深，终于有幸在工作期间接触到了一些项目和需求，更幸运的是项目组在开发时采用的架构正好是整洁架构，详细的说，是事件驱动开发DDD+整洁架构，关于DDD的详细内容将会在之后讨论，笔者就重新阅读了这本书📚，收获颇丰，因此这一个系列，我准备用自己的拙见描述一下整洁架构，更准确的说，应该是是读书笔记，以兹同仁。\u003c/p\u003e\n\u003cp\u003e这本书的详细地址为：\u003ca href=\"https://weread.qq.com/web/bookDetail/480322f072021a3248038c8\"\u003e架构整洁之道-罗伯特 C. 马丁-微信读书 (qq.com)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e本系列会以图书的章节组织作为思路，跟随作者的脚步逐渐深入，同时，由于是再读，所以不可避免的也会穿插一些图书中其他部分的内容，所以，如果你在阅读时发现了一些难于理解或者没听说过的内容，那它大概率是在之后章节中的内容。\u003c/p\u003e\n\u003cp\u003e让我们开始吧。\u003c/p\u003e\n\u003ch2 id=\"设计与架构的含义\"\u003e设计与架构的含义\u003c/h2\u003e\n\u003cp\u003e设计与架构，本质上并没有区别，底层设计细节和顶层架构信息共同定义了软件系统。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e软件架构的终极目标是用最小的人力成本来满足构建和维护系统的需求\u003c/strong\u003e，因此成本可以评估一个软件架构设计的优劣。\u003c/p\u003e\n\u003cp\u003e没有经过设计、匆匆构建的系统可能成为\u003cstrong\u003e乱麻系统\u003c/strong\u003e，乱麻系统在构建过程中被长期忽视代码质量和设计结构优化。认真设计软件架构可以在一定程度上避免系统成为乱麻系统，从而降低成本。\u003c/p\u003e\n\u003cp\u003e软件开发具有两个核心特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e要想跑得快，要先跑得稳；\u003c/li\u003e\n\u003cli\u003e过度自信只会使得重构设计陷入和原项目一样的困局。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"两个价值维度\"\u003e两个价值维度\u003c/h2\u003e\n\u003cp\u003e软件系统包含两种价值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e行为价值：让机器按照某种指定方式运转，给系统的使用者创造或者提高利润；\u003c/li\u003e\n\u003cli\u003e架构价值：软件要够灵活，更改软件的成本要做到与需求的范畴相关，与形状无关。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e怎么理解需求的范畴与形状？\n笔者自己理解范畴即需求大致的范围和所属\u003cstrong\u003e领域\u003c/strong\u003e，而形状指需求的细节内容。\u003c/p\u003e\n\u003cp\u003e那么哪个价值维度更重要呢？\n作者认为架构价值比行为价值更重要，因为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0；\u003c/li\u003e\n\u003cli\u003e如果某程序目前无法正常工作，但是我们可以很容易地修改它，那么将它改好，并且随着需求变化不停地修改它，都应该是很容易的事。因此，这个程序会持续产生价值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e业务部门与研发部门经常犯的共同错误是没有把真正紧急并且重要的功能和紧急但是不重要的功能分开，结果就是重要的系统架构问题让位给了不重要的系统行为功能。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e笔者注：同时，即便同样是研发人员，不同的小组也会存在类似问题，正如某些前端部门认为后台只需要提供一系列接口很容易，而不知道良好设计的重要性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"为好的软件架构持续斗争\"\u003e为好的软件架构持续斗争✊\u003c/h3\u003e\n\u003cp\u003e如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。\u003c/p\u003e\n","description":"再读整洁架构之道（一）","image":"/blogimages/arh1.png","permalink":"https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%B8%80/","title":"再读整洁架构之道（一）"},{"content":"\u003ch3 id=\"问题简述\"\u003e问题简述\u003c/h3\u003e\n\u003cp\u003e在日常的模型开发、训练过程中我们经常会遇到这样的现象：在现有的开源项目或者论文复现中，多数模型使用Pytorch设计、开发和训练推理，当我们需要使用MindSpore框架进行模型开发时，会遇到以下两个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e模型使用Pytorch编码；\u003c/li\u003e\n\u003cli\u003ePytorch模型训练后保存的参数无法被MindSpore模型直接加载。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于第一个问题，我们可以根据昇思官方提供的文档：\u003ca href=\"https://www.mindspore.cn/docs/zh-CN/r2.1/migration_guide/typical_api_comparision.html#%E4%B8%8Epytorch%E5%85%B8%E5%9E%8B%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB\"\u003e与Pytorch典型区别\u003c/a\u003e和\u003ca href=\"https://www.mindspore.cn/docs/zh-CN/r2.1/note/api_mapping/pytorch_api_mapping.html#pytorch%E4%B8%8Emindspore-api%E6%98%A0%E5%B0%84%E8%A1%A8\"\u003ePyTorch与MindSpore API映射表\u003c/a\u003e来完成模型的迁移；\u003c/p\u003e\n\u003cp\u003e对于模型参数的转换，在最新的MindSpore版本中MindConverter不再支持，因此可以考虑针对模型参数，我们进行\u003cstrong\u003e手动的转换\u003c/strong\u003e，将Pytorch模型参数转换为MindSpore能识别的格式后，再进行加载。\u003c/p\u003e\n\u003ch3 id=\"解决方案\"\u003e解决方案\u003c/h3\u003e\n\u003cp\u003e模型的编码转换不再赘述。\u003c/p\u003e\n\u003cp\u003e参数转换主要思路如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用Pytorch加载Pytorch模型，并取得模型参数prams_torch；\u003c/li\u003e\n\u003cli\u003e使用MindSpore加载MindSpore模型，并取得模型参数prams_ms；\u003c/li\u003e\n\u003cli\u003e将Pytorch模型的参数名和MindSpore模型参数名一一对应（有的话）；\u003c/li\u003e\n\u003cli\u003e建立torch_2_ms键名映射表，使用键名映射表将Pytorch模型参数值加载到MindSpore参数名对应的位置上；\u003c/li\u003e\n\u003cli\u003e使用MindSpore加载参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"案例分析\"\u003e案例分析\u003c/h3\u003e\n\u003cp\u003e不同模型的模块不相同，参数类型也不尽相同，此处我们以一个网络举例，说明转换的基本思路，不同的模型其转换思路是类似的。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/1905.11946\"\u003eEfficientNet\u003c/a\u003e是谷歌于2019年发表的文章，详细网络架构可查看文章描述，此处我们以\u003cstrong\u003eEfficientNet+FC\u003c/strong\u003e全连接层的模型为例，探讨如何进行网络模型参数的转换。\u003c/p\u003e\n\u003ch4 id=\"使用pytorch加载pytorch模型并取得模型参数prams_torch\"\u003e使用Pytorch加载Pytorch模型，并取得模型参数prams_torch\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e test.efficientnet_pytorch.model \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e EfficientNet \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e EN_pytorch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epytorch_model \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e EN_pytorch\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003efrom_name(cfg[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;model\u0026#39;\u003c/span\u003e], override_params\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;num_classes\u0026#39;\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epytorch_model\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecuda()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epytorch_weights_dict \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pytorch_model\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003estate_dict()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_torch \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pytorch_weights_dict\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ekeys()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_torch_lst \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eDataFrame(param_torch)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_torch_lst\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eto_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;param_torch.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e步骤结束后，我们就将pytorch的模型参数存到了param_torch.csv下，观察数据：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003ekeys\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e_conv_stem.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e_bn0.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e_bn0.bias\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e_bn0.running_mean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003e_bn0.running_var\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e_bn0.num_batches_tracked\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e_blocks.0._depthwise_conv.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003e_blocks.0._bn1.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e_blocks.0._bn1.bias\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003ctd\u003e_blocks.0._bn1.running_mean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003ctd\u003e_blocks.0._bn1.running_var\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"使用mindspore加载mindspore模型并取得模型参数prams_ms\"\u003e使用MindSpore加载MindSpore模型，并取得模型参数prams_ms\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e mindspore \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e test.efficientnet_mindspore.model \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e EfficientNet \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e EN_ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emindspore_model \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e EN_ms\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003efrom_name(cfg[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;model\u0026#39;\u003c/span\u003e], override_params\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e{\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;num_classes\u0026#39;\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprams_ms \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e mindspore_model\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eparameters_dict()\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ekeys()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprams_ms_lst \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eDataFrame(prams_ms)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprams_ms_lst\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eto_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;prams_ms.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e步骤结束后，我们就将MindSpore的模型参数存到了prams_ms.csv下，观察数据：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003ekeys\u003c/th\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e_conv_stem.weight\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e_bn0.moving_mean\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003e_bn0.moving_variance\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e3\u003c/td\u003e\n\u003ctd\u003e_bn0.gamma\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003e_bn0.beta\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e0._depthwise_conv.weight\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e6\u003c/td\u003e\n\u003ctd\u003e0._bn1.moving_mean\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003e0._bn1.moving_variance\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003e0._bn1.gamma\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e9\u003c/td\u003e\n\u003ctd\u003e0._bn1.beta\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e10\u003c/td\u003e\n\u003ctd\u003e0._se_reduce.weight\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4 id=\"将pytorch模型的参数名和mindspore模型参数名一一对应\"\u003e将Pytorch模型的参数名和MindSpore模型参数名一一对应\u003c/h4\u003e\n\u003cp\u003e自此我们就得到了MindSpore和Pytorch各自的参数键名表（附在附件区域），随后观察二者参数命名上的差异，可以发现固定的规律，以下述几个方面为例：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBatch Normalization：\n\u003cul\u003e\n\u003cli\u003e权重：weight|bias——gamma|beta；\u003c/li\u003e\n\u003cli\u003e移动加权和方差：running_mean|running_var——moving_mean|moving_variance；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e自定义blocks：pytorch带前置的_blocks.；\u003c/li\u003e\n\u003cli\u003e其他\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"键名映射表\"\u003e键名映射表\u003c/h4\u003e\n\u003cp\u003e这样就可以根据规律写出一个Python脚本来完成键名的转化，并生成键名映射表：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003ePytorch\u003c/th\u003e\n\u003cth\u003emindspore\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e_conv_stem.weight\u003c/td\u003e\n\u003ctd\u003e_conv_stem.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_bn0.weight\u003c/td\u003e\n\u003ctd\u003e_bn0.gamma\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_bn0.bias\u003c/td\u003e\n\u003ctd\u003e_bn0.beta\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_bn0.running_mean\u003c/td\u003e\n\u003ctd\u003e_bn0.moving_mean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_bn0.running_var\u003c/td\u003e\n\u003ctd\u003e_bn0.moving_variance\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._depthwise_conv.weight\u003c/td\u003e\n\u003ctd\u003e0._depthwise_conv.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._bn1.weight\u003c/td\u003e\n\u003ctd\u003e0._bn1.gamma\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._bn1.bias\u003c/td\u003e\n\u003ctd\u003e0._bn1.beta\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._bn1.running_mean\u003c/td\u003e\n\u003ctd\u003e0._bn1.moving_mean\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._bn1.running_var\u003c/td\u003e\n\u003ctd\u003e0._bn1.moving_variance\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e_blocks.0._se_reduce.weight\u003c/td\u003e\n\u003ctd\u003e0._se_reduce.weight\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e随后在Pytorch的权重字典中，按照对应文件的Pytorch_key取出权重值，随后使用mindspore.Parameter进行封装，添加到mindspore.key对应的权值中去：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e i \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e ms_param_lst\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003evalues:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ms_key \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e i\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pt_key \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e param_mapping[ms_key]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pt_val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pt_values_dict[pt_key]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e isinstance(pt_val, np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003endarray):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pt_val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pt_val\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecpu()\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enumpy()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ms_val \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Parameter(pt_val, ms_key)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(ms_val)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ms_values_dict[ms_key] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e ms_val\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"使用mindspore加载参数\"\u003e使用MindSpore加载参数\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eload_param_into_net(mindspore_model, ms_values_dict)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e此时，参数应该就可以被MindSpore接受了。\u003c/p\u003e\n\u003ch3 id=\"whats-more\"\u003eWhat\u0026rsquo;s more\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在参数值的存储过程中，要注意Pytorch和MindSpore参数精度的差异；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（完）\u003c/p\u003e\n","description":"本文描述了Pytorch模型及参数与MindSpore模型、参数转换执行时的问题，同时给出了一种可行的解决方案完成Pytorch-\u003eMindSpore的转换。","image":"/blogimages/p2m.png","permalink":"https://tommycheese.github.io/blogs/%E5%AE%9E%E7%94%A8%E5%B9%B2%E8%B4%A7%E5%A6%82%E4%BD%95%E6%8A%8Apytorch%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD%E5%88%B0mindspore%E6%A8%A1%E5%9E%8B/","title":"实用干货：如何把Pytorch模型参数加载到MindSpore模型？"},{"content":"\u003cp\u003e本文讨论研究梯度下降法的一个有力的数学工具：海森矩阵。在讨论海森矩阵之前，需要首先了解梯度和雅克比矩阵的基本概念。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e:star:本文假设读者已经熟悉梯度下降法和简单的数值分析、线性代数知识\n\u003ca href=\"https://tommycheese.github.io/blogs/%E6%A2%AF%E5%BA%A6%E4%B9%8B%E4%B8%8Ahessian-%E7%9F%A9%E9%98%B5/\"\u003e原文链接\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"梯度雅克比矩阵\"\u003e梯度、雅克比矩阵\u003c/h2\u003e\n\u003cp\u003e梯度下降算法需要当前函数点的导数信息，当此函数点包含多个方向时，梯度是包含所有方向的（偏）导数向量。\u003c/p\u003e\n\u003cp\u003e上述情况对应于\u003cstrong\u003e输出为一个\u003c/strong\u003e的情况，当函数的输出也为一个向量时，我们需要把输出向量的每一个元素对于多个输入的梯度\u003cstrong\u003e罗列在一起\u003c/strong\u003e，罗列形成的矩阵就是\u003cstrong\u003e雅克比矩阵（Jacobian Matrix）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e举例说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若函数$f$接受三个输入$x1、x2、x3$，产生一个输出$y$，则其梯度为：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e$$\n\\begin{equation}\nGrad = [\\frac{\\partial y}{\\partial x_1}, \\frac{\\partial y}{\\partial x_2}, \\frac{\\partial y}{\\partial x_3}]\n\\end{equation}\n$$\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若函数$f2$接受三个输入$x1、x2、x3$，产生三个输出$y1、y2、y3$，则其雅克比矩阵为：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e$$\n\\begin{equation}\nJacobian  = \\begin{bmatrix}\n\\frac{\\partial y_1}{\\partial x_1} \u0026amp;  \\frac{\\partial y_1}{\\partial x_2}\u0026amp;\\frac{\\partial y_1}{\\partial x_3} \\\n\\frac{\\partial y_2}{\\partial x_1} \u0026amp;  \\frac{\\partial y_2}{\\partial x_2}\u0026amp;\\frac{\\partial y_2}{\\partial x_3} \\\n\\frac{\\partial y_3}{\\partial x_1} \u0026amp;  \\frac{\\partial y_3}{\\partial x_2}\u0026amp;\\frac{\\partial y_3}{\\partial x_3}\n\\end{bmatrix}\n\\end{equation}\n$$\u003c/p\u003e\n\u003cp\u003e利用二阶导数，我们可以知道关于函数在特定方向 $d$ 上的凹凸信息，利用凹凸信息可以在一定程度上预判梯度下降法的表现效果。如果在特定方向 $d$ 上：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e二阶导数为正，则函数在方向$d$上一阶导数增加，函数值下降更慢；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e二阶导数为负，则函数在方向$d$上一阶导数减少，函数值下降更快；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e二阶导数为零，则函数在方向$d$上一阶导数不变，函数值匀速下降；\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e:star:注意在梯度下降法中是对损失函数进行下降，因此需要使用减函数来分析函数中\u003cstrong\u003e某一小段\u003c/strong\u003e（经常使用二次函数的减半部近似：二阶泰勒展开、牛顿法）中的导数变化情况；\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"海森矩阵\"\u003e海森矩阵\u003c/h2\u003e\n\u003cp\u003e和雅克比矩阵类似，\u003cstrong\u003e海森矩阵（Hessian 矩阵）\u003cstrong\u003e可以包含函数中二阶导的信息：\n$$\nHessian   = \\begin{bmatrix}\n\\frac{\\partial^2y}{\\partial x_1\\partial x_1} \u0026amp;  \\frac{\\partial^2y}{\\partial x_1\\partial x_2}\u0026amp;\\frac{\\partial^2y}{\\partial x_1\\partial x_3} \\\n\\frac{\\partial^2y}{\\partial x_2\\partial x_1} \u0026amp;  \\frac{\\partial^2y}{\\partial x_2\\partial x_2}\u0026amp;\\frac{\\partial^2y}{\\partial x_2\\partial x_3} \\\n\\frac{\\partial^2y}{\\partial x_3\\partial x_1} \u0026amp;  \\frac{\\partial^2y}{\\partial x_3\\partial x_2}\u0026amp;\\frac{\\partial^2y}{\\partial x_3\\partial x_3}\n\\end{bmatrix}\n$$\n同时由于二阶导数计算顺序的可交换性，即 $\\frac{\\partial^2y}{\\partial x_1\\partial x_2}=\\frac{\\partial^2y}{\\partial x_2\\partial x_1}$，因此\u003c/strong\u003e海森矩阵是一个对称矩阵\u003c/strong\u003e，对于对称矩阵我们可以使用\u003cstrong\u003e特征分解\u003c/strong\u003e来研究特征值和二阶导数的关系，便于我们快速获得某个方向的二阶导数。\u003c/p\u003e\n\u003cp\u003e针对于特定方向d，已知此方向的二阶导数可以写成 $d^THd$ ，则：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e:link: \u003ca href=\"https://blog.csdn.net/weixin_42397505/article/details/112066943\"\u003e基于Hessian矩阵的二阶方向导数与性质_Hi 喀什噶尔的胡杨的博客-CSDN博客_二阶方向导数\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e若d是H对应特征值λ的特征向量：\u003c/p\u003e\n\u003cp\u003e因为d为对应λ的特征向量（以下简称特征向量），则据定义有：\n$$\nHd = \\lambda d\\\n\\Rightarrow  d^THd=d^T\\lambda d = \\lambda d^Td=\\lambda    \\ \\ \\ 对称矩阵d^T = d^-\n$$\u003c/p\u003e\n\u003cp\u003e因此特征向量对应的特征值λ即为此方向的二阶导数；\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若d为其他方向：设$e_i$为$H$对应特征值$\\lambda_i$的特征向量，由上可知，\n$$\n\\lambda_i=e_i^THe_i\n$$\n可知任何一个方向$d=\\sum_i^mt_ie_i$为特征向量的线性组合，其中m为特征值个数，$t_i$为第$i$个特征向量的加权数，则：\n$$\nd^THd=(\\sum_i^mt_ie_i)^TH(\\sum_i^mt_ie_i)=\\sum_i^mt_ie_i^THt_ie_i=\\sum_i^mt_i^2\\lambda_i\n$$\n因此任意非特征向量方向的二阶导数是所有特征值的加权和，特别的，此时的加权和是一个椭球体，在二维的特征值情况下，二阶导数是一个椭圆，椭圆方程为：\n$$\ny=\\frac{\\lambda_1}{\\frac{1}{t_1^2}}+\\frac{\\lambda_2}{\\frac{1}{t_2^2}}\n$$\n\u003cimg src=\"https://img-blog.csdnimg.cn/img_convert/bb30779d25d486346799cb0fce7d34ad.png#pic_center\" alt=\"在这里插入图片描述\"\u003e\u003c/p\u003e\n\u003cp\u003e由图可知，最大二阶导数由最大特征值决定（长半轴），而最小二阶导数由最小特征值决定（短半轴）。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"海森矩阵应用\"\u003e海森矩阵应用\u003c/h2\u003e\n\u003cp\u003e在弄清海森矩阵的基本定义后，就可以使用海森矩阵的一些性质来分析优化方法中的一些问题了。如确定局部最大点、局部最小点和鞍点、确定学习率、以及使用病态条件来确定梯度下降的表现等，同时我们还可以利用Hessian矩阵来实现\u003cstrong\u003e牛顿法\u003c/strong\u003e这种优化算法，。\u003c/p\u003e\n\u003cp\u003e（本节完）\u003c/p\u003e\n","description":"本文讨论研究梯度下降法的一个有力的数学工具：海森矩阵。","image":"/blogimages/hessen.png","permalink":"https://tommycheese.github.io/blogs/h/","title":"梯度之上：Hessian 矩阵"},{"content":"","description":"🌏","image":null,"permalink":"https://tommycheese.github.io/gallery/","title":"探索|Explore"},{"content":"\u003cp\u003e前记：在之前笔者阅读过架构之道这本书，但当时缺乏项目的锻炼和试错，总觉得读的不深。实习期间接触到了一些项目和需求和对应的实践，同时老师也推荐阅读本书，笔者就重新进行了阅读📚，收获颇丰，记录的欲望又开始蠢蠢欲动，因此这一个系列，我准备用自己的拙见描述一下书籍的内容。\u003c/p\u003e\n\u003cp\u003e这本书的在线地址为：\u003ca href=\"https://weread.qq.com/web/bookDetail/480322f072021a3248038c8\"\u003e架构整洁之道-罗伯特 C. 马丁-微信读书 (qq.com)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e本系列会以图书的章节组织作为思路，跟随作者的脚步逐渐深入，同时，由于是再读，所以不可避免的也会穿插一些图书中其他部分的内容，所以，如果在阅读时发现了一些新鲜的内容，那它大概率出现在之后章节。\u003c/p\u003e\n\u003cp\u003e让我们开始吧。\u003c/p\u003e\n\u003ch1 id=\"软件架构\"\u003e软件架构\u003c/h1\u003e\n\u003ch2 id=\"设计与架构的含义\"\u003e设计与架构的含义\u003c/h2\u003e\n\u003cp\u003e设计与架构，本质上并没有区别，底层设计细节和顶层架构信息共同定义了软件系统。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e软件架构的终极目标是用最小的人力成本来满足构建和维护系统的需求\u003c/strong\u003e，因此成本可以评估一个软件架构设计的优劣。\u003c/p\u003e\n\u003cp\u003e没有经过设计、匆匆构建的系统可能成为\u003cstrong\u003e乱麻系统\u003c/strong\u003e，乱麻系统在构建过程中被长期忽视代码质量和设计结构优化。认真设计软件架构可以在一定程度上避免系统成为乱麻系统，从而降低成本。\u003c/p\u003e\n\u003cp\u003e软件开发具有两个核心特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e要想跑得快，要先跑得稳；\u003c/li\u003e\n\u003cli\u003e过度自信只会使得重构设计陷入和原项目一样的困局。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"两个价值维度\"\u003e两个价值维度\u003c/h2\u003e\n\u003cp\u003e软件系统包含两种价值：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e行为价值：让机器按照某种指定方式运转，给系统的使用者创造或者提高利润；\u003c/li\u003e\n\u003cli\u003e架构价值：软件要够灵活，更改软件的成本要做到与需求的范畴相关，与形状无关。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e怎么理解需求的范畴与形状？\n笔者自己理解范畴即需求大致的范围和所属\u003cstrong\u003e领域\u003c/strong\u003e，而形状指需求的细节内容。\u003c/p\u003e\n\u003cp\u003e那么哪个价值维度更重要呢？\n作者认为架构价值比行为价值更重要，因为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0；\u003c/li\u003e\n\u003cli\u003e如果某程序目前无法正常工作，但是我们可以很容易地修改它，那么将它改好，并且随着需求变化不停地修改它，都应该是很容易的事。因此，这个程序会持续产生价值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e业务部门与研发部门经常犯的共同错误是没有把真正紧急并且重要的功能和紧急但是不重要的功能分开，结果就是重要的系统架构问题让位给了不重要的系统行为功能。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e✨注：同时，即便同样是研发人员，有时不同的小组也会存在类似问题。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"为好的软件架构持续斗争\"\u003e为好的软件架构持续斗争✊\u003c/h3\u003e\n\u003cp\u003e如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。\u003c/p\u003e\n\u003ch1 id=\"编程范式\"\u003e编程范式\u003c/h1\u003e\n\u003cp\u003e编程范式指的是程序的编写模式，它告诉我们应该在什么时候采用什么样的代码结构。\u003c/p\u003e\n\u003cp\u003e截止目前，一共出现了三种编程范式：结构化编程范式、面向对象编程范式和函数式编程。\u003c/p\u003e\n\u003cp\u003e作者认为，每种编程方式不是在给架构设计者的武器库进行扩充，相反，架构师和程序员的武器已经够多了，这三种编程范式是在对他们利用的武器进行\u003cstrong\u003e限制\u003c/strong\u003e，这也是为什么他们叫做“范式”。\u003c/p\u003e\n\u003ch2 id=\"结构化编程范式\"\u003e结构化编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e结构化编程对程序控制权的直接转移进行了限制和规范，特别指的是限制了程序中goto的随意使用。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"分解程序\"\u003e分解程序\u003c/h3\u003e\n\u003cp\u003eDijkstra希望使用数学推导方法对程序进行推理证明：让程序就成为了一种欧几里得结构，这样可以用一些已经证明的结构串联起新的程序，从而进一步推导整个程序的正确性。\u003c/p\u003e\n\u003cp\u003e他还发现，如果程序中包含大量的goto，那么程序会变得难以分解，而goto语句的作用完全可以依靠分支和循环来完成。\u003c/p\u003e\n\u003cp\u003e这样，结构化编程范式表明，程序可以进行降解拆分，一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此无限递归。更重要的是，每个被拆分出来的函数也都可以用结构化编程范式来书写。\u003c/p\u003e\n\u003cp\u003e但是，这种形式化证明的编程方式没有成为主流，科学证明法是目前使用较多的方法。\u003c/p\u003e\n\u003ch3 id=\"科学证明法\"\u003e科学证明法\u003c/h3\u003e\n\u003cp\u003e科学理论和科学定律可以被证伪，但是没有办法被证明，类似的，程序只能测试证伪，不能证明，即“测试只能展示Bug的存在，并不能证明不存在Bug”。因此，利用科学证明法，结构化编程范式就可以促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的\u003cstrong\u003e测试\u003c/strong\u003e来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。\u003c/p\u003e\n\u003ch2 id=\"面向对象编程范式\"\u003e面向对象编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e面向对象编程对程序控制权的间接转移进行了限制和规范。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e具体来说，面向对象编程凡事使用\u003cstrong\u003e多态特性\u003c/strong\u003e限制了函数指针的使用。这可以理解为函数指针只能进行有限制的指向，比如java中的多态一般出现在有继承关系的两个类的对象之间。\u003c/p\u003e\n\u003cp\u003e作者也认为多态是OOP的最大特性，利用多态可以做到\u003cstrong\u003e依赖反转\u003c/strong\u003e：\u003c/p\u003e\n\u003cp\u003e依赖反转即引入接口，完全控制系统中所有源代码的依赖关系，而不需要收到系统控制流的制约。\u003c/p\u003e\n\u003cp\u003e依赖反转保证了我们可以对系统进行插件式的开发，如将web UI和数据库与业务逻辑之间的依赖进行反转，可以保证主业务逻辑与UI和数据库的解耦，这样UI和数据库就成了主业务逻辑的插件。\u003c/p\u003e\n\u003cp\u003e面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。\u003c/p\u003e\n\u003ch2 id=\"函数式编程范式\"\u003e函数式编程范式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e函数式编程对程序中的赋值进行了限制和规范。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e换句话说，函数式编程语言中变量是不可变的。\u003c/p\u003e\n\u003cp\u003e作者有以下的观点，这一段话来自原文：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题\u0026quot;\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果不考虑储存器与处理器的速度限制，那么不可变性是可行的，但实际上我们必须考虑这些因素，因此可变性只能在一定程度上可行，需要让不可变性在一定程度上可行需要完成\u003cstrong\u003e可变性的隔离\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"可变性的隔离\"\u003e可变性的隔离\u003c/h3\u003e\n\u003cp\u003e可变性隔离的一种常见方式是将应用程序，或者是应用程序的内部服务进行切分，\u003cstrong\u003e划分为可变的和不可变的两种组件\u003c/strong\u003e。不可变组件用纯函数的方式来执行任务，期间不更改任何状态。这些不可变的组件将通过与一个或多个非函数式组件（即可变组件）通信的方式来修改变量状态。\u003c/p\u003e\n\u003cp\u003e一个例子是GIT版本管理工具。它通过移动指针来记录文件的变化：增删改，但实际上文件并没有被真正的修改和删除，只存在增加和检索查询两种情况，这不就是不可变性的一个例子吗。\u003c/p\u003e\n\u003cp\u003e同时，mysql中的事务管理、事务性内存的工作也都运用了这个思想。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e三种编程范式与软件架构具有密切的关系：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多态是我们跨越边界的手段；\u003c/li\u003e\n\u003cli\u003e函数式编程是我们规范和限制数据存放位置与访问权限的手段；\u003c/li\u003e\n\u003cli\u003e结构化编程则是个模块的实现基础；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e三种编程范式与软件架构的三大关注重点不谋而合：\u003cstrong\u003e组件独立性\u003c/strong\u003e（面向对象）、\u003cstrong\u003e数据管理\u003c/strong\u003e（函数式）以及功能性（结构）。\u003c/p\u003e\n\u003ch2 id=\"再次思考\"\u003e再次思考\u003c/h2\u003e\n\u003cp\u003e三种编程范式都对程序员提出了新的\u003cstrong\u003e限制\u003c/strong\u003e。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，编程范式带来的是——什么不应该做。\u003c/p\u003e\n\u003cp\u003e（第一篇完）\u003c/p\u003e\n","description":null,"image":null,"permalink":"https://tommycheese.github.io/blogs/test/","title":""}]