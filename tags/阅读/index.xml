<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>阅读 on Tommy Cheese</title>
    <link>https://tommycheese.github.io/tags/%E9%98%85%E8%AF%BB/</link>
    <description>Recent content in 阅读 on Tommy Cheese</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Jul 2024 07:25:33 +0800</lastBuildDate>
    <atom:link href="https://tommycheese.github.io/tags/%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>再读整洁架构之道（二）</title>
      <link>https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%BA%8C/</link>
      <pubDate>Fri, 05 Jul 2024 07:25:33 +0800</pubDate>
      <guid>https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%BA%8C/</guid>
      <description>再读整洁架构之道（二） 编程范式指的是程序的编写模式，它告诉我们应该在什么时候采用什么样的代码结构。&#xA;截止目前，一共出现了三种编程范式：结构化编程范式、面向对象编程范式和函数式编程。&#xA;作者认为，每种编程方式不是在给架构设计者的武器库进行扩充，相反，架构师和程序员的武器已经够多了，这三种编程范式是在对他们利用的武器进行限制，这也是为什么他们叫做“范式”。&#xA;结构化编程范式 结构化编程对程序控制权的直接转移进行了限制和规范，特别指的是限制了程序中goto的随意使用。&#xA;分解程序 Dijkstra希望使用数学推导方法对程序进行推理证明：让程序就成为了一种欧几里得结构，这样可以用一些已经证明的结构串联起新的程序，从而进一步推导整个程序的正确性。&#xA;他还发现，如果程序中包含大量的goto，那么程序会变得难以分解，而goto语句的作用完全可以依靠分支和循环来完成。&#xA;这样，结构化编程范式表明，程序可以进行降解拆分，一个大型问题拆分为一系列高级函数的组合，而这些高级函数各自又可以继续被拆分为一系列低级函数，如此无限递归。更重要的是，每个被拆分出来的函数也都可以用结构化编程范式来书写。&#xA;但是，这种形式化证明的编程方式没有成为主流，科学证明法是目前使用较多的方法。&#xA;科学证明法 科学理论和科学定律可以被证伪，但是没有办法被证明，类似的，程序只能测试证伪，不能证明，即“测试只能展示Bug的存在，并不能证明不存在Bug”。因此，利用科学证明法，结构化编程范式就可以促使我们先将一段程序递归降解为一系列可证明的小函数，然后再编写相关的测试来试图证明这些函数是错误的。如果这些测试无法证伪这些函数，那么我们就可以认为这些函数是足够正确的，进而推导整个程序是正确的。&#xA;面向对象编程范式 面向对象编程对程序控制权的间接转移进行了限制和规范。&#xA;具体来说，面向对象编程凡事使用多态特性限制了函数指针的使用。这可以理解为函数指针只能进行有限制的指向，比如java中的多态一般出现在有继承关系的两个类的对象之间。&#xA;作者也认为多态是OOP的最大特性，利用多态可以做到依赖反转：&#xA;依赖反转即引入接口，完全控制系统中所有源代码的依赖关系，而不需要收到系统控制流的制约。&#xA;依赖反转保证了我们可以对系统进行插件式的开发，如将web UI和数据库与业务逻辑之间的依赖进行反转，可以保证主业务逻辑与UI和数据库的解耦，这样UI和数据库就成了主业务逻辑的插件。&#xA;面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。&#xA;函数式编程范式 函数式编程对程序中的赋值进行了限制和规范。&#xA;换句话说，函数式编程语言中变量是不可变的。&#xA;作者有以下的观点，这一段话来自原文：&#xA;“所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的。如果变量永远不会被更改，那就不可能产生竞争或者并发更新问题。如果锁状态是不可变的，那就永远不会产生死锁问题&amp;quot;&#xA;如果不考虑储存器与处理器的速度限制，那么不可变性是可行的，但实际上我们必须考虑这些因素，因此可变性只能在一定程度上可行，需要让不可变性在一定程度上可行需要完成可变性的隔离。&#xA;可变性的隔离 可变性隔离的一种常见方式是将应用程序，或者是应用程序的内部服务进行切分，划分为可变的和不可变的两种组件。不可变组件用纯函数的方式来执行任务，期间不更改任何状态。这些不可变的组件将通过与一个或多个非函数式组件（即可变组件）通信的方式来修改变量状态。&#xA;一个例子是GIT版本管理工具。它通过移动指针来记录文件的变化：增删改，但实际上文件并没有被真正的修改和删除，只存在增加和检索查询两种情况，这不就是不可变性的一个例子吗。&#xA;同时，mysql中的事务管理、事务性内存的工作也都运用了这个思想。&#xA;总结 三种编程范式与软件架构具有密切的关系：&#xA;多态是我们跨越边界的手段； 函数式编程是我们规范和限制数据存放位置与访问权限的手段； 结构化编程则是个模块的实现基础； 三种编程范式与软件架构的三大关注重点不谋而合：组件独立性（面向对象）、数据管理（函数式）以及功能性（结构）。&#xA;再次思考 三种编程范式都对程序员提出了新的限制。每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力。也就是说，编程范式带来的是——什么不应该做。&#xA;（第二篇完）</description>
    </item>
    <item>
      <title>再读整洁架构之道（一）</title>
      <link>https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%B8%80/</link>
      <pubDate>Wed, 03 Jul 2024 23:10:20 +0800</pubDate>
      <guid>https://tommycheese.github.io/blogs/%E5%86%8D%E8%AF%BB%E6%95%B4%E6%B4%81%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E4%B8%80/</guid>
      <description>前记 为什么是再读？因为在这之前笔者已经阅读过一遍架构之道这本书，但当时缺乏项目的锻炼和试错，总觉得读的不深，终于有幸在工作期间接触到了一些项目和需求，更幸运的是项目组在开发时采用的架构正好是整洁架构，详细的说，是事件驱动开发DDD+整洁架构，关于DDD的详细内容将会在之后讨论，笔者就重新阅读了这本书📚，收获颇丰，因此这一个系列，我准备用自己的拙见描述一下整洁架构，更准确的说，应该是是读书笔记，以兹同仁。&#xA;这本书的详细地址为：架构整洁之道-罗伯特 C. 马丁-微信读书 (qq.com)&#xA;本系列会以图书的章节组织作为思路，跟随作者的脚步逐渐深入，同时，由于是再读，所以不可避免的也会穿插一些图书中其他部分的内容，所以，如果你在阅读时发现了一些难于理解或者没听说过的内容，那它大概率是在之后章节中的内容。&#xA;让我们开始吧。&#xA;设计与架构的含义 设计与架构，本质上并没有区别，底层设计细节和顶层架构信息共同定义了软件系统。&#xA;软件架构的终极目标是用最小的人力成本来满足构建和维护系统的需求，因此成本可以评估一个软件架构设计的优劣。&#xA;没有经过设计、匆匆构建的系统可能成为乱麻系统，乱麻系统在构建过程中被长期忽视代码质量和设计结构优化。认真设计软件架构可以在一定程度上避免系统成为乱麻系统，从而降低成本。&#xA;软件开发具有两个核心特点：&#xA;要想跑得快，要先跑得稳； 过度自信只会使得重构设计陷入和原项目一样的困局。 两个价值维度 软件系统包含两种价值：&#xA;行为价值：让机器按照某种指定方式运转，给系统的使用者创造或者提高利润； 架构价值：软件要够灵活，更改软件的成本要做到与需求的范畴相关，与形状无关。 怎么理解需求的范畴与形状？ 笔者自己理解范畴即需求大致的范围和所属领域，而形状指需求的细节内容。&#xA;那么哪个价值维度更重要呢？ 作者认为架构价值比行为价值更重要，因为：&#xA;如果某程序可以正常工作，但是无法修改，那么当需求变更的时候它就不再能够正常工作了，我们也无法通过修改让它能继续正常工作。因此，这个程序的价值将成为0； 如果某程序目前无法正常工作，但是我们可以很容易地修改它，那么将它改好，并且随着需求变化不停地修改它，都应该是很容易的事。因此，这个程序会持续产生价值。 业务部门与研发部门经常犯的共同错误是没有把真正紧急并且重要的功能和紧急但是不重要的功能分开，结果就是重要的系统架构问题让位给了不重要的系统行为功能。&#xA;平衡系统架构的重要性与功能的紧急程度这件事，是软件研发人员自己的职责。&#xA;笔者注：同时，即便同样是研发人员，不同的小组也会存在类似问题，正如某些前端部门认为后台只需要提供一系列接口很容易，而不知道良好设计的重要性。&#xA;为好的软件架构持续斗争 如果忽视软件架构的价值，系统将会变得越来越难以维护，终会有一天，系统将会变得再也无法修改。如果系统变成了这个样子，那么说明软件开发团队没有和需求方做足够的抗争，没有完成自己应尽的职责。</description>
    </item>
  </channel>
</rss>
